{"version":3,"sources":["../neutron.ts"],"sourcesContent":["/*\n * ███╗   ██╗███████╗██╗   ██╗████████╗██████╗  ██████╗ ███╗   ██╗\n * ████╗  ██║██╔════╝██║   ██║╚══██╔══╝██╔══██╗██╔═══██╗████╗  ██║\n * ██╔██╗ ██║█████╗  ██║   ██║   ██║   ██████╔╝██║   ██║██╔██╗ ██║\n * ██║╚██╗██║██╔══╝  ██║   ██║   ██║   ██╔══██╗██║   ██║██║╚██╗██║\n * ██║ ╚████║███████╗╚██████╔╝   ██║   ██║  ██║╚██████╔╝██║ ╚████║\n * ╚═╝  ╚═══╝╚══════╝ ╚═════╝    ╚═╝   ╚═╝  ╚═╝ ╚═════╝ ╚═╝  ╚═══╝\n */\n\n/**\n * Neutron namespace provides a game engine framework for creating interactive applications;\n * includes core functionality for rendering, game state management, and event handling and more.\n */\nexport namespace Neutron {\n  /**\n   * Interface defining the settings and components required to initialize the game engine.\n   */\n  interface EngineSettings {\n    /** HTMLCanvasElement for the game. This is where all rendering will occur. */\n    canvas: HTMLCanvasElement;\n    /** Target ticks per second for the game loop. Controls how often the game state updates. */\n    tps: number;\n    /** Scale of the canvas. 1 is normal, 2 is double the size, 3 is triple the size, etc. */\n    scale: number;\n    /** Events object that implements the Events interface for handling user input. */\n    events: Events;\n\n    /** Function called every frame when drawing the game. Handles all rendering operations. */\n    draw: () => void;\n    /** Function called every tick when updating the game state. Handles game logic and physics. */\n    update: () => void;\n    /** Function called to initialize the game. Sets up initial game state. */\n    init: () => void;\n    /** Function called to load game assets */\n    load: () => void;\n  }\n\n  /**\n   * Manages the game loop, rendering, and game state updates.\n   * The Engine class is responsible for:\n   * - Controlling frame rate and game speed\n   * - Managing performance monitoring\n   * - Handling game state updates\n   * - Coordinating between different game systems\n   */\n  class Engine {\n    /** Current frames per second. Updated every second. */\n    private fps: number;\n    /** Current ticks per second. Updated every second. */\n    private tps: number;\n    /** Counter for FPS (frames per second) calculation. Reset every second. */\n    private fpsCounter: number;\n    /** Counter for TPS (ticks per second) calculation. Reset every second. */\n    private tpsCounter: number;\n    /** Target ticks per second for the game loop. Controls game speed. */\n    private idealTps: number;\n    /** Timestamp of the last update. Used for delta time calculation. */\n    private lastUpdateTime: number;\n    /** Minimum time between updates in milliseconds. Based on idealTps. */\n    private minFrameTime: number;\n    /** Accumulated time since last update. Used for fixed time step updates. */\n    private accumulatedTime: number;\n    /** Maximum number of updates per frame. */\n    private maxUpdatesPerFrame: number;\n    /** Whether to enable frame skipping for slow devices. */\n    private enableFrameSkipping: boolean;\n    /** Number of frames to skip when behind. Helps maintain performance. */\n    private framesToSkip: number;\n    /** Whether to log performance info to console. */\n    private logPerformanceInfo: boolean;\n    /** Whether the game loop should stop. */\n    private stopVal: boolean;\n    /** Whether the game has been initialized. */\n    private hasInited: boolean;\n    /** Whether the game has loaded all assets. */\n    private hasLoadedAssets: boolean;\n    /** Function called every frame when updating the game. */\n    private update: () => void;\n    /** Function called to initialize the game. */\n    private initFunc: () => void;\n\n    /**\n     * Initializes default values for performance monitoring and game loop settings.\n     * Sets up the engine with reasonable defaults for most games.\n     */\n    constructor() {\n      this.fps = 0;\n      this.tps = 0;\n      this.fpsCounter = 0;\n      this.tpsCounter = 0;\n      this.idealTps = 70;\n      this.lastUpdateTime = performance.now();\n      this.minFrameTime = 1000 / this.idealTps;\n      this.accumulatedTime = 0;\n      this.maxUpdatesPerFrame = 5;\n      this.enableFrameSkipping = true;\n      this.framesToSkip = 1;\n      this.logPerformanceInfo = false;\n      this.stopVal = false;\n      this.hasInited = false;\n      this.hasLoadedAssets = false;\n      this.update = () => {};\n      this.initFunc = () => {};\n    }\n\n    /**\n     * Initializes the game engine with the provided settings.\n     * Sets up the render loop, game state management, and event handling.\n     *\n     * @param engineSettings - Configuration object containing all necessary engine components\n     * @throws Error if required components are missing or invalid\n     */\n    init(engineSettings: EngineSettings): void {\n      const render = new Render(\n        engineSettings.canvas,\n        engineSettings.draw,\n        engineSettings.scale\n      );\n      const loader = new Loader();\n      const events = engineSettings.events;\n      const controller = new Controller(render, this, events);\n      const game = new Game();\n      const camera = new Camera();\n\n      getRender = () => render;\n      getLoader = () => loader;\n      getEvents = () => events;\n      getController = () => controller;\n      getGame = () => game;\n      getCamera = () => camera;\n\n      this.idealTps = engineSettings.tps;\n      this.minFrameTime = 1000 / this.idealTps;\n      this.initFunc = engineSettings.init;\n\n      this.update = () => {\n        getGame()\n          .getParticles()\n          .forEach((particle: Particle) => particle.update());\n\n        getGame()\n          .getSprites()\n          .forEach((sprite: Sprite) => sprite.update());\n\n        const camera = getCamera();\n        if (camera.getToFollow() !== null) {\n          const toFollow = camera.getToFollow() as Sprite;\n          camera.setX(toFollow.getX() - getRender().getWidth() / 2);\n          camera.setY(toFollow.getY() - getRender().getHeight() / 2);\n        }\n\n        if (events.isMouseDown && events.mouseEvent) {\n          events.whileMouseDown(events.mouseEvent);\n        }\n\n        engineSettings.update();\n      };\n\n      engineSettings.load();\n\n      if (getLoader().getNumberOfAssetsToLoad() !== 0) {\n        this.hasLoadedAssets = true;\n      }\n\n      this.startLoop();\n      this.startPerformanceTracker();\n    }\n\n    /**\n     * Starts the main game loop.\n     * @private\n     */\n    private startLoop = (): void => {\n      if (this.stopVal) {\n        return;\n      }\n\n      if (getLoader().getNumberOfAssetsToLoad() === 0) {\n        this.hasLoadedAssets = false;\n      }\n\n      if (this.hasLoadedAssets) {\n        window.requestAnimationFrame(this.startLoop);\n        return;\n      }\n\n      if (!this.hasInited) {\n        this.initFunc();\n        this.hasInited = true;\n      }\n\n      this.fpsCounter++;\n\n      const currentTime = performance.now();\n      const deltaTime = currentTime - this.lastUpdateTime;\n      this.lastUpdateTime = currentTime;\n      this.accumulatedTime += deltaTime;\n\n      let updates = 0;\n      while (\n        this.accumulatedTime >= this.minFrameTime &&\n        updates < this.maxUpdatesPerFrame\n      ) {\n        this.update();\n        this.tpsCounter++;\n        this.accumulatedTime -= this.minFrameTime;\n        updates++;\n      }\n\n      if (\n        this.enableFrameSkipping &&\n        this.accumulatedTime > this.minFrameTime * this.framesToSkip\n      ) {\n        this.accumulatedTime = 0;\n      } else if (this.accumulatedTime > this.minFrameTime * 5) {\n        this.accumulatedTime = this.minFrameTime * 5;\n      }\n\n      getRender().drawFunction()();\n\n      window.requestAnimationFrame(this.startLoop);\n    };\n\n    /**\n     * Starts the performance tracker to monitor frame rate and ticks per second;\n     * updates FPS and TPS counters every second. Logs performance info to the console.\n     */\n    private startPerformanceTracker = (): void => {\n      setInterval(() => {\n        this.fps = this.fpsCounter;\n        this.tps = this.tpsCounter;\n        this.fpsCounter = 0;\n        this.tpsCounter = 0;\n\n        if (this.logPerformanceInfo) {\n          console.log(\n            `%cNeutron Performance Info\\n%cFPS: %c${this.fps}%c | TPS: %c${this.tps}%c | Target TPS: %c${this.idealTps}%c\\nMin Frame Time: %c${this.minFrameTime}ms%c | Accumulated Time: %c${this.accumulatedTime}ms`,\n            \"font-weight: bold; font-size: 14px; color: #4CAF50;\",\n            \"color: #888;\",\n            \"color: #2196F3; font-weight: bold;\",\n            \"color: #888;\",\n            \"color: #2196F3; font-weight: bold;\",\n            \"color: #888;\",\n            \"color: #2196F3; font-weight: bold;\",\n            \"color: #888;\",\n            \"color: #FF9800; font-weight: bold;\",\n            \"color: #888;\",\n            \"color: #FF9800; font-weight: bold;\"\n          );\n        }\n      }, 1000);\n    };\n\n    /**\n     * Stops the game engine loop.\n     */\n    stop(): void {\n      this.stopVal = true;\n    }\n\n    /**\n     * Starts or resumes the game engine loop.\n     * Resets timing variables.\n     */\n    start(): void {\n      if (this.stopVal) {\n        this.stopVal = false;\n        this.lastUpdateTime = performance.now();\n        this.accumulatedTime = 0;\n        this.startLoop();\n      }\n    }\n\n    /**\n     * Gets the performance info.\n     * @returns The performance info object\n     */\n    getPerformanceInfo() {\n      return {\n        fps: this.fps,\n        tps: this.tps,\n        idealTps: this.idealTps,\n        minFrameTime: this.minFrameTime,\n        accumulatedTime: this.accumulatedTime,\n      };\n    }\n\n    /**\n     * Gets the current frames per second.\n     * @returns The current FPS value\n     */\n    getFps(): number {\n      return this.fps;\n    }\n\n    /**\n     * Gets the current ticks per second.\n     * @returns The current TPS value\n     */\n    getTps(): number {\n      return this.tps;\n    }\n\n    /**\n     * Sets whether to log the performance info.\n     * @param _val - Whether to log the performance info\n     */\n    setLoggingPerformanceInfo(_val: boolean): void {\n      this.logPerformanceInfo = _val;\n    }\n\n    /**\n     * Gets whether the engine is logging performance info.\n     * @returns Whether the engine is logging performance info\n     */\n    isLoggingPerformanceInfo(): boolean {\n      return this.logPerformanceInfo;\n    }\n\n    /**\n     * Gets the ideal ticks per second.\n     * @returns The ideal TPS value\n     */\n    getIdealTps(): number {\n      return this.idealTps;\n    }\n\n    /**\n     * Sets the ideal ticks per second.\n     * @param _val - The ideal TPS value\n     */\n    setIdealTps(_val: number): void {\n      this.idealTps = _val;\n    }\n\n    /**\n     * Sets whether to enable frame skipping.\n     * @param _val - Whether to enable frame skipping\n     */\n    setEnableFrameSkipping(_val: boolean): void {\n      this.enableFrameSkipping = _val;\n    }\n\n    /**\n     * Gets whether frame skipping is enabled.\n     * @returns Whether frame skipping is enabled\n     */\n    getEnableFrameSkipping(): boolean {\n      return this.enableFrameSkipping;\n    }\n  }\n\n  /**\n   * Handles the rendering of the game.\n   */\n  class Render {\n    /** The Canvas Element */\n    private canvas: HTMLCanvasElement;\n    /** The WebGL Context */\n    private ctx: WebGL2RenderingContext;\n    /** The Shader Program */\n    private shaderProgram: WebGLProgram;\n    /** The Vertex Array Object */\n    private vao: WebGLVertexArrayObject;\n    /** The Position Buffer */\n    private positionBuffer: WebGLBuffer;\n    /** The Color Buffer */\n    private colorBuffer: WebGLBuffer;\n    /** The Texcoord Buffer */\n    private texcoordBuffer: WebGLBuffer;\n    /** The Position Attribute Location */\n    private aPosition: number;\n    /** The Color Attribute Location */\n    private aColor: number;\n    /** The Texcoord Attribute Location */\n    private aTexcoord: number;\n    /** The Projection Uniform Location */\n    private uProjection: WebGLUniformLocation;\n    /** The Model Uniform Location */\n    private uModel: WebGLUniformLocation;\n    /** The View Uniform Location */\n    private uView: WebGLUniformLocation;\n    /** The Rotation Uniform Location */\n    private uRotation: WebGLUniformLocation;\n    /** The Alpha Uniform Location */\n    private uAlpha: WebGLUniformLocation;\n    /** The Vertex Shader Source */\n    private vertexShaderSource: string;\n    /** Eclipse Segments */\n    private eclipseSegments: number;\n    /** The Scale */\n    private scale: number;\n    /** The Full Screen Ratio */\n    private fullScreenRatio: [number, number] | null;\n    /** The Draw Function */\n    private draw: () => void;\n\n    /**\n     * Constructor for the Render class.\n     * @param canvas - The HTMLCanvasElement to render on\n     * @param draw - The function to draw on the canvas\n     * @param scale - The scale of the canvas\n     */\n    constructor(canvas: HTMLCanvasElement, draw: () => void, scale: number) {\n      this.eclipseSegments = 100;\n      this.canvas = canvas;\n      this.ctx = this.canvas.getContext(\"webgl2\") as WebGL2RenderingContext;\n      if (!this.ctx) {\n        throw new Error(\"WebGL2 not supported\");\n      }\n      this.fullScreenRatio = null;\n      this.draw = draw;\n      this.scale = scale;\n\n      const rect = this.canvas.getBoundingClientRect();\n\n      this.canvas.width = rect.width * this.scale;\n      this.canvas.height = rect.height * this.scale;\n\n      this.vertexShaderSource = `#version 300 es\n        in vec2 a_position;\n        in vec2 a_texcoord;\n        in vec4 a_color;\n\n        out vec2 v_texcoord;\n        out vec4 v_color;\n\n        uniform mat4 u_projection;\n        uniform mat4 u_view;\n        uniform mat4 u_model;\n        uniform float u_rotation;\n\n        void main() {\n          float c = cos(u_rotation);\n          float s = sin(u_rotation);\n          mat2 rotation = mat2(c, -s, s, c);\n          vec2 rotatedPos = rotation * a_position;\n          gl_Position = u_projection * u_view * u_model * vec4(rotatedPos, 0.0, 1.0);\n          v_texcoord = a_texcoord;\n          v_color = a_color;\n        }\n      `;\n\n      const fsSource = `#version 300 es\n        precision mediump float;\n\n        in vec2 v_texcoord;\n        in vec4 v_color;\n        out vec4 fragColor;\n\n        uniform sampler2D u_texture;\n        uniform bool u_useTexture;\n        uniform float u_alpha;\n\n        void main() {\n          if (u_useTexture) {\n            vec4 texColor = texture(u_texture, v_texcoord);\n            fragColor = vec4(texColor.rgb, texColor.a * u_alpha);\n          } else {\n            fragColor = vec4(v_color.rgb, v_color.a * u_alpha);\n          }\n        }\n      `;\n\n      const vertexShader = this.ctx.createShader(this.ctx.VERTEX_SHADER);\n\n      if (vertexShader === null) {\n        throw new Error(`Vertex shader is null!`);\n      }\n\n      this.ctx.shaderSource(vertexShader, this.vertexShaderSource);\n      this.ctx.compileShader(vertexShader);\n\n      if (!this.ctx.getShaderParameter(vertexShader, this.ctx.COMPILE_STATUS)) {\n        this.ctx.deleteShader(vertexShader);\n        throw new Error(\n          `Vertex shader compilation failed! Info: ${this.ctx.getShaderInfoLog(\n            vertexShader\n          )}`\n        );\n      }\n\n      const fragmentShader = this.ctx.createShader(this.ctx.FRAGMENT_SHADER);\n\n      if (fragmentShader === null) {\n        throw new Error(`Fragment shader is null!`);\n      }\n\n      this.ctx.shaderSource(fragmentShader, fsSource);\n      this.ctx.compileShader(fragmentShader);\n\n      if (\n        !this.ctx.getShaderParameter(fragmentShader, this.ctx.COMPILE_STATUS)\n      ) {\n        throw new Error(\n          `Fragment shader compilation failed! Info: ${this.ctx.getShaderInfoLog(\n            fragmentShader\n          )}`\n        );\n      }\n\n      this.shaderProgram = this.ctx.createProgram();\n\n      this.ctx.attachShader(this.shaderProgram, vertexShader);\n      this.ctx.attachShader(this.shaderProgram, fragmentShader);\n      this.ctx.linkProgram(this.shaderProgram);\n\n      if (\n        !this.ctx.getProgramParameter(this.shaderProgram, this.ctx.LINK_STATUS)\n      ) {\n        throw new Error(\n          `Program linking failed! Info: ${this.ctx.getProgramInfoLog(\n            this.shaderProgram\n          )}`\n        );\n      }\n\n      this.ctx.useProgram(this.shaderProgram);\n\n      this.aPosition = this.ctx.getAttribLocation(\n        this.shaderProgram,\n        \"a_position\"\n      );\n\n      this.aColor = this.ctx.getAttribLocation(this.shaderProgram, \"a_color\");\n\n      this.aTexcoord = this.ctx.getAttribLocation(\n        this.shaderProgram,\n        \"a_texcoord\"\n      );\n\n      const uProjection = this.ctx.getUniformLocation(\n        this.shaderProgram,\n        \"u_projection\"\n      );\n      if (uProjection === null) {\n        throw new Error(\"Could not get uniform location for u_projection\");\n      }\n      this.uProjection = uProjection;\n\n      const uModel = this.ctx.getUniformLocation(this.shaderProgram, \"u_model\");\n      if (uModel === null) {\n        throw new Error(\"Could not get uniform location for u_model\");\n      }\n      this.uModel = uModel;\n\n      const uView = this.ctx.getUniformLocation(this.shaderProgram, \"u_view\");\n      if (uView === null) {\n        throw new Error(\"Could not get uniform location for u_view\");\n      }\n      this.uView = uView;\n\n      const uRotation = this.ctx.getUniformLocation(\n        this.shaderProgram,\n        \"u_rotation\"\n      );\n      if (uRotation === null) {\n        throw new Error(\"Could not get uniform location for u_rotation\");\n      }\n      this.uRotation = uRotation;\n\n      const uAlpha = this.ctx.getUniformLocation(this.shaderProgram, \"u_alpha\");\n      if (uAlpha === null) {\n        throw new Error(\"Could not get uniform location for u_alpha\");\n      }\n      this.uAlpha = uAlpha;\n\n      this.positionBuffer = this.ctx.createBuffer();\n      this.colorBuffer = this.ctx.createBuffer();\n\n      this.vao = this.ctx.createVertexArray();\n      this.ctx.bindVertexArray(this.vao);\n\n      this.ctx.bindBuffer(this.ctx.ARRAY_BUFFER, this.positionBuffer);\n      this.ctx.enableVertexAttribArray(this.aPosition as number);\n      this.ctx.vertexAttribPointer(\n        this.aPosition as number,\n        2,\n        this.ctx.FLOAT,\n        false,\n        0,\n        0\n      );\n\n      this.ctx.bindBuffer(this.ctx.ARRAY_BUFFER, this.colorBuffer);\n      this.ctx.enableVertexAttribArray(this.aColor as number);\n      this.ctx.vertexAttribPointer(\n        this.aColor as number,\n        4,\n        this.ctx.FLOAT,\n        false,\n        0,\n        0\n      );\n\n      this.texcoordBuffer = this.ctx.createBuffer();\n      this.ctx.bindBuffer(this.ctx.ARRAY_BUFFER, this.texcoordBuffer);\n      this.ctx.enableVertexAttribArray(this.aTexcoord);\n      this.ctx.vertexAttribPointer(\n        this.aTexcoord,\n        2,\n        this.ctx.FLOAT,\n        false,\n        0,\n        0\n      );\n\n      this.ctx.bindVertexArray(null);\n\n      this.ctx.viewport(0, 0, this.canvas.width, this.canvas.height);\n    }\n\n    /**\n     * Returns a function that draws the game on the canvas.\n     * @returns The draw function\n     */\n    drawFunction() {\n      return (() => {\n        this.ctx.viewport(0, 0, this.canvas.width, this.canvas.height);\n        this.ctx.clearColor(0.0, 0.0, 0.0, 1.0);\n        this.ctx.clear(this.ctx.COLOR_BUFFER_BIT);\n\n        const image = getGame().getBackgroundImage();\n\n        if (image !== null) {\n          this.drawImage(0, 0, this.getWidth(), this.getHeight(), image);\n        }\n\n        getGame()\n          .getParticles()\n          .forEach((particle) => {\n            if (particle.isOnScreen()) {\n              this.drawParticle(particle);\n              particle.draw();\n            }\n          });\n\n        getGame()\n          .getSprites()\n          .forEach((sprite) => {\n            if (sprite.isOnScreen()) {\n              this.drawSprite(sprite);\n              sprite.draw();\n            }\n          });\n\n        this.draw();\n      }).bind(this);\n    }\n\n    /**\n     * Draws a sprite on the canvas.\n     * @param object - The sprite to draw\n     */\n    private drawSprite(object: Sprite): void {\n      if (object.getEffect().getHidden()) {\n        return;\n      }\n\n      const alpha = 1 - object.getEffect().getTransparency() / 100;\n      const color = this.hexToRgb(object.getColor());\n      const rotation = (object.getEffect().getRotation() * Math.PI) / 180;\n\n      if (object.getCostumes().getCostume() !== null) {\n        const image = object.getCostumes().getCostume() as HTMLImageElement;\n        this.drawImage(\n          object.getX() - getCamera().getX(),\n          object.getY() - getCamera().getY(),\n          object.getWidth(),\n          object.getHeight(),\n          image,\n          alpha,\n          rotation\n        );\n        return;\n      }\n\n      if (object.getEffect().getIsEclipse()) {\n        this.drawEclipse(\n          object.getX() - getCamera().getX(),\n          object.getY() - getCamera().getY(),\n          object.getWidth(),\n          object.getHeight(),\n          [color[0], color[1], color[2]],\n          alpha,\n          rotation\n        );\n        return;\n      }\n\n      this.drawRect(\n        object.getX() - getCamera().getX(),\n        object.getY() - getCamera().getY(),\n        object.getWidth(),\n        object.getHeight(),\n        [color[0], color[1], color[2]],\n        alpha,\n        rotation\n      );\n    }\n\n    /**\n     * Draws a particle on the canvas.\n     * @param particle - The particle to draw\n     */\n    private drawParticle(particle: Particle): void {\n      if (particle.getEffects().getHidden()) {\n        return;\n      }\n\n      const alpha = 1 - particle.getEffects().getTransparency() / 100;\n      const color = this.hexToRgb(particle.getColor());\n      const rotation = (particle.getEffects().getRotation() * Math.PI) / 180;\n\n      if (particle.getEffects().getIsEclipse()) {\n        this.drawEclipse(\n          particle.getX() - getCamera().getX(),\n          particle.getY() - getCamera().getY(),\n          particle.getWidth(),\n          particle.getHeight(),\n          [color[0], color[1], color[2]],\n          alpha,\n          rotation\n        );\n        return;\n      }\n\n      this.drawRect(\n        particle.getX() - getCamera().getX(),\n        particle.getY() - getCamera().getY(),\n        particle.getWidth(),\n        particle.getHeight(),\n        [color[0], color[1], color[2]],\n        alpha,\n        rotation\n      );\n    }\n\n    /**\n     * Converts hex color string to RGB array.\n     * @param hex - The hex color\n     * @returns The RGB color\n     */\n    private hexToRgb(hex: string): number[] {\n      const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n      return result\n        ? [\n            parseInt(result[1], 16) / 255,\n            parseInt(result[2], 16) / 255,\n            parseInt(result[3], 16) / 255,\n          ]\n        : [0, 0, 0];\n    }\n\n    /**\n     * Draws a rectangle on the canvas.\n     * @param x - X position\n     * @param y - Y position\n     * @param width - Width\n     * @param height - Height\n     * @param color - Color\n     * @param alpha - Alpha\n     * @param rotation - Rotation\n     */\n    private drawRect(\n      x: number,\n      y: number,\n      width: number,\n      height: number,\n      color: [number, number, number],\n      alpha: number = 1,\n      rotation: number = 0\n    ): void {\n      const uUseTexture = this.ctx.getUniformLocation(\n        this.shaderProgram,\n        \"u_useTexture\"\n      );\n      this.ctx.uniform1i(uUseTexture, 0);\n\n      this.ctx.enable(this.ctx.BLEND);\n      this.ctx.blendFunc(this.ctx.SRC_ALPHA, this.ctx.ONE_MINUS_SRC_ALPHA);\n\n      const positions = [\n        -width / 2,\n        -height / 2,\n        width / 2,\n        -height / 2,\n        -width / 2,\n        height / 2,\n        width / 2,\n        height / 2,\n      ];\n\n      const colors = [\n        color[0],\n        color[1],\n        color[2],\n        1,\n        color[0],\n        color[1],\n        color[2],\n        1,\n        color[0],\n        color[1],\n        color[2],\n        1,\n        color[0],\n        color[1],\n        color[2],\n        1,\n      ];\n\n      const projMatrix = this.orthographic(\n        0,\n        this.canvas.width,\n        this.canvas.height,\n        0\n      );\n\n      const translationMatrix = new Float32Array([\n        1,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        x + width / 2,\n        y + height / 2,\n        0,\n        1,\n      ]);\n\n      this.ctx.uniform1f(this.uAlpha, alpha);\n\n      this.ctx.uniformMatrix4fv(this.uProjection, false, projMatrix);\n      this.ctx.uniformMatrix4fv(this.uView, false, translationMatrix);\n      this.ctx.uniformMatrix4fv(\n        this.uModel,\n        false,\n        new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1])\n      );\n\n      this.ctx.uniform1f(this.uRotation, rotation);\n\n      this.ctx.useProgram(this.shaderProgram);\n      this.ctx.bindVertexArray(this.vao);\n\n      this.ctx.bindBuffer(this.ctx.ARRAY_BUFFER, this.positionBuffer);\n      this.ctx.bufferData(\n        this.ctx.ARRAY_BUFFER,\n        new Float32Array(positions),\n        this.ctx.STATIC_DRAW\n      );\n\n      this.ctx.vertexAttribPointer(\n        this.aPosition as number,\n        2,\n        this.ctx.FLOAT,\n        false,\n        0,\n        0\n      );\n\n      this.ctx.bindBuffer(this.ctx.ARRAY_BUFFER, this.colorBuffer);\n      this.ctx.bufferData(\n        this.ctx.ARRAY_BUFFER,\n        new Float32Array(colors),\n        this.ctx.STATIC_DRAW\n      );\n\n      this.ctx.vertexAttribPointer(\n        this.aColor as number,\n        4,\n        this.ctx.FLOAT,\n        false,\n        0,\n        0\n      );\n\n      this.ctx.drawArrays(this.ctx.TRIANGLE_STRIP, 0, 4);\n\n      this.ctx.bindVertexArray(null);\n    }\n\n    /**\n     * Draws an image on the canvas.\n     * @param x - The x position\n     * @param y - The y position\n     * @param width - The width\n     * @param height - The height\n     * @param image - The image to draw\n     * @param alpha - Alpha\n     * @param rotation - Rotation\n     */\n    private drawImage(\n      x: number,\n      y: number,\n      width: number,\n      height: number,\n      image: WebGLTexture,\n      alpha: number = 1,\n      rotation: number = 0\n    ) {\n      const uUseTexture = this.ctx.getUniformLocation(\n        this.shaderProgram,\n        \"u_useTexture\"\n      );\n      this.ctx.uniform1i(uUseTexture, 1);\n\n      this.ctx.enable(this.ctx.BLEND);\n      this.ctx.blendFunc(this.ctx.SRC_ALPHA, this.ctx.ONE_MINUS_SRC_ALPHA);\n\n      const positions = new Float32Array([\n        -width / 2,\n        -height / 2,\n        width / 2,\n        -height / 2,\n        -width / 2,\n        height / 2,\n        width / 2,\n        height / 2,\n      ]);\n\n      const texcoords = new Float32Array([\n        0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 1.0, 1.0,\n      ]);\n\n      const projMatrix = this.orthographic(\n        0,\n        this.canvas.width,\n        this.canvas.height,\n        0\n      );\n\n      const translationMatrix = new Float32Array([\n        1,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        x + width / 2,\n        y + height / 2,\n        0,\n        1,\n      ]);\n\n      const modelMatrix = new Float32Array([\n        1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1,\n      ]);\n\n      this.ctx.useProgram(this.shaderProgram);\n\n      this.ctx.uniform1f(this.uAlpha, alpha);\n      this.ctx.uniformMatrix4fv(this.uProjection, false, projMatrix);\n      this.ctx.uniformMatrix4fv(this.uView, false, translationMatrix);\n      this.ctx.uniformMatrix4fv(this.uModel, false, modelMatrix);\n      this.ctx.uniform1f(this.uRotation, rotation);\n      this.ctx.uniform1i(\n        this.ctx.getUniformLocation(this.shaderProgram, \"u_useTexture\"),\n        1\n      );\n\n      this.ctx.bindBuffer(this.ctx.ARRAY_BUFFER, this.positionBuffer);\n      this.ctx.bufferData(\n        this.ctx.ARRAY_BUFFER,\n        positions,\n        this.ctx.DYNAMIC_DRAW\n      );\n      this.ctx.enableVertexAttribArray(this.aPosition);\n      this.ctx.vertexAttribPointer(\n        this.aPosition,\n        2,\n        this.ctx.FLOAT,\n        false,\n        0,\n        0\n      );\n\n      this.ctx.bindBuffer(this.ctx.ARRAY_BUFFER, this.texcoordBuffer);\n      this.ctx.bufferData(\n        this.ctx.ARRAY_BUFFER,\n        texcoords,\n        this.ctx.DYNAMIC_DRAW\n      );\n      this.ctx.enableVertexAttribArray(this.aTexcoord);\n      this.ctx.vertexAttribPointer(\n        this.aTexcoord,\n        2,\n        this.ctx.FLOAT,\n        false,\n        0,\n        0\n      );\n\n      this.ctx.disableVertexAttribArray(this.aColor);\n\n      this.ctx.activeTexture(this.ctx.TEXTURE0);\n      this.ctx.bindTexture(this.ctx.TEXTURE_2D, image);\n      const uTexture = this.ctx.getUniformLocation(\n        this.shaderProgram,\n        \"u_texture\"\n      );\n      this.ctx.uniform1i(uTexture, 0);\n\n      this.ctx.drawArrays(this.ctx.TRIANGLE_STRIP, 0, 4);\n\n      this.ctx.bindBuffer(this.ctx.ARRAY_BUFFER, null);\n    }\n\n    /**\n     * Draws an eclipse on the canvas.\n     * @param x - The x position\n     * @param y - The y position\n     * @param width - The width\n     * @param height - The height\n     * @param color - The color\n     * @param alpha - Alpha\n     * @param rotation - Rotation\n     */\n    private drawEclipse(\n      x: number,\n      y: number,\n      width: number,\n      height: number,\n      color: [number, number, number],\n      alpha: number = 1,\n      rotation: number = 0\n    ) {\n      const uUseTexture = this.ctx.getUniformLocation(\n        this.shaderProgram,\n        \"u_useTexture\"\n      );\n      this.ctx.uniform1i(uUseTexture, 0);\n\n      this.ctx.enable(this.ctx.BLEND);\n      this.ctx.blendFunc(this.ctx.SRC_ALPHA, this.ctx.ONE_MINUS_SRC_ALPHA);\n\n      const positions = this.createEclipseVertices(\n        x,\n        y,\n        width / 2,\n        height / 2,\n        this.eclipseSegments\n      );\n      const numVertices = positions.length / 2;\n\n      const colors = new Float32Array(numVertices * 4);\n      for (let i = 0; i < numVertices; i++) {\n        const offset = i * 4;\n        colors[offset] = color[0];\n        colors[offset + 1] = color[1];\n        colors[offset + 2] = color[2];\n        colors[offset + 3] = 1.0;\n      }\n\n      const projMatrix = this.orthographic(\n        0,\n        this.canvas.width,\n        this.canvas.height,\n        0\n      );\n\n      const translationMatrix = new Float32Array([\n        1,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        x + width / 2,\n        y + height / 2,\n        0,\n        1,\n      ]);\n\n      this.ctx.useProgram(this.shaderProgram);\n\n      this.ctx.uniform1f(this.uAlpha, alpha);\n      this.ctx.uniformMatrix4fv(this.uProjection, false, projMatrix);\n      this.ctx.uniformMatrix4fv(this.uView, false, translationMatrix);\n      this.ctx.uniformMatrix4fv(\n        this.uModel,\n        false,\n        new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1])\n      );\n      this.ctx.uniform1f(this.uRotation, rotation);\n      this.ctx.uniform1i(\n        this.ctx.getUniformLocation(this.shaderProgram, \"u_useTexture\"),\n        0\n      );\n\n      this.ctx.bindBuffer(this.ctx.ARRAY_BUFFER, this.positionBuffer);\n      this.ctx.bufferData(\n        this.ctx.ARRAY_BUFFER,\n        new Float32Array(positions),\n        this.ctx.DYNAMIC_DRAW\n      );\n      this.ctx.enableVertexAttribArray(this.aPosition);\n      this.ctx.vertexAttribPointer(\n        this.aPosition,\n        2,\n        this.ctx.FLOAT,\n        false,\n        0,\n        0\n      );\n\n      this.ctx.bindBuffer(this.ctx.ARRAY_BUFFER, this.colorBuffer);\n      this.ctx.bufferData(this.ctx.ARRAY_BUFFER, colors, this.ctx.DYNAMIC_DRAW);\n      this.ctx.enableVertexAttribArray(this.aColor);\n      this.ctx.vertexAttribPointer(this.aColor, 4, this.ctx.FLOAT, false, 0, 0);\n\n      this.ctx.disableVertexAttribArray(this.aTexcoord);\n\n      this.ctx.drawArrays(this.ctx.TRIANGLE_FAN, 0, numVertices);\n\n      this.ctx.bindBuffer(this.ctx.ARRAY_BUFFER, null);\n    }\n\n    /**\n     * Creates the eclipse vertices.\n     * @param cx - The x position\n     * @param cy - The y position\n     * @param rx - The x radius\n     * @param ry - The y radius\n     * @param segments - The segments\n     * @returns The vertices\n     */\n    private createEclipseVertices(\n      cx: number,\n      cy: number,\n      rx: number,\n      ry: number,\n      segments: number = 100\n    ): number[] {\n      const vertices = [cx, cy];\n\n      for (let i = 0; i <= segments; i++) {\n        const theta = (i / segments) * 2 * Math.PI;\n        const x = cx + rx * Math.cos(theta);\n        const y = cy + ry * Math.sin(theta);\n        vertices.push(x, y);\n      }\n\n      return vertices;\n    }\n\n    /**\n     * Orthographic projection.\n     * @param left - The left\n     * @param right - The right\n     * @param bottom - The bottom\n     * @param top - The top\n     * @returns The orthographic projection\n     */\n    private orthographic(\n      left: number,\n      right: number,\n      bottom: number,\n      top: number\n    ): Float32Array {\n      return new Float32Array([\n        2 / (right - left),\n        0,\n        0,\n        0,\n        0,\n        2 / (top - bottom),\n        0,\n        0,\n        0,\n        0,\n        -1,\n        0,\n        -(right + left) / (right - left),\n        -(top + bottom) / (top - bottom),\n        0,\n        1,\n      ]);\n    }\n\n    /**\n     * Ajusts the canvas to the window size without a set ratio.\n     */\n    ajustCanvas() {\n      this.canvas.style.width = `${window.innerWidth}px`;\n      this.canvas.style.height = `${window.innerHeight}px`;\n\n      this.canvas.width = window.innerWidth * this.scale;\n      this.canvas.height = window.innerHeight * this.scale;\n\n      this.canvas.style.position = \"absolute\";\n      this.canvas.style.left = \"0\";\n      this.canvas.style.top = \"0\";\n    }\n\n    /**\n     * Ajusts the canvas to the window size with a set ratio.\n     * @param xRatio - The x ratio\n     * @param yRatio - The y ratio\n     */\n    ajustCanvasRatio(xRatio: number, yRatio: number) {\n      this.fullScreenRatio = [xRatio, yRatio];\n      if (window.innerHeight > window.innerWidth * (yRatio / xRatio)) {\n        this.canvas.style.width = `${window.innerWidth}px`;\n        this.canvas.style.height = `${window.innerWidth * (yRatio / xRatio)}px`;\n      } else {\n        this.canvas.style.width = `${window.innerHeight * (xRatio / yRatio)}px`;\n        this.canvas.style.height = `${window.innerHeight}px`;\n      }\n    }\n\n    /**\n     * Gets the canvas.\n     * @returns The canvas\n     */\n    getCanvas() {\n      return this.canvas;\n    }\n\n    /**\n     * Gets the width of the canvas.\n     * @returns The width of the canvas\n     */\n    getWidth() {\n      return this.canvas.width;\n    }\n\n    /**\n     * Gets the height of the canvas.\n     * @returns The height of the canvas\n     */\n    getHeight() {\n      return this.canvas.height;\n    }\n\n    /**\n     * Gets the context of the canvas.\n     * @returns The context of the canvas\n     */\n    getCtx() {\n      return this.ctx;\n    }\n\n    /**\n     * Gets the scale of the canvas.\n     * @returns The scale of the canvas\n     */\n    getScale(): number {\n      return this.scale;\n    }\n\n    /**\n     * Gets the eclipse segments.\n     * @returns The eclipse segments\n     */\n    getEclipseSegments(): number {\n      return this.eclipseSegments;\n    }\n\n    /**\n     * Sets the eclipse segments.\n     * @param segments - The segments\n     */\n    setEclipseSegments(segments: number) {\n      this.eclipseSegments = segments;\n    }\n\n    /**\n     * Gets the full screen ratios.\n     * @returns The full screen ratios\n     */\n    getAdjustedCanvasRatios(): [number, number] | null {\n      return this.fullScreenRatio;\n    }\n  }\n\n  /** Handles the loading of game assets. */\n  class Loader {\n    /** Image assets */\n    private images: {\n      [id: string]: WebGLTexture;\n    };\n    /** Audio assets */\n    private audio: { [id: string]: HTMLAudioElement };\n    /** The number of assets to load */\n    private assetsToLoad: number;\n\n    /**\n     * Constructor for the Loader class.\n     */\n    constructor() {\n      this.images = {};\n      this.audio = {};\n      this.assetsToLoad = 0;\n    }\n\n    /**\n     * Loads an image.\n     * @param id - The id of the image\n     * @param src - The source of the image\n     */\n    loadImage(id: string, src: string) {\n      this.assetsToLoad++;\n      let image = new Image();\n      image.src = src;\n      this.images[id] = image;\n      image.onload = () => {\n        this.assetsToLoad--;\n\n        const ctx = Neutron.getRender().getCtx();\n        const texture = ctx.createTexture();\n        ctx.bindTexture(ctx.TEXTURE_2D, texture);\n\n        ctx.texImage2D(\n          ctx.TEXTURE_2D,\n          0,\n          ctx.RGBA,\n          ctx.RGBA,\n          ctx.UNSIGNED_BYTE,\n          image\n        );\n\n        ctx.generateMipmap(ctx.TEXTURE_2D);\n\n        this.images[id] = texture;\n      };\n    }\n\n    /**\n     * Loads an audio.\n     * @param id - The id of the audio\n     * @param src - The source of the audio\n     */\n    loadAudio(id: string, src: string) {\n      this.assetsToLoad++;\n      let audio = new Audio(src);\n      this.audio[id] = audio;\n      audio.onload = () => this.assetsToLoad--;\n    }\n\n    /**\n     * Gets the loaded image by id.\n     * @param id - The id of the image\n     * @returns The loaded image\n     */\n    getLoadedImageById = (id: string) => this.images[id];\n\n    /**\n     * Gets the loaded audio by id.\n     * @param id - The id of the audio\n     * @returns The loaded audio\n     */\n    getLoadedAudioById = (id: string) => this.audio[id];\n\n    /**\n     * Gets the number of assets to load.\n     * @returns The number of assets to load\n     */\n    getNumberOfAssetsToLoad() {\n      return this.assetsToLoad;\n    }\n  }\n\n  /** Handles the events of the game. */\n  export interface Events {\n    /** The mouse event */\n    mouseEvent: MouseEvent | null;\n    /** The touch event */\n    touchEvent: TouchEvent | null;\n    /** Whether the mouse is down */\n    isMouseDown: boolean;\n    /** Whether the touch is down */\n    isTouchDown: boolean;\n\n    /** Handles the on key down event */\n    onKeyDown(e: KeyboardEvent): void;\n    /** Handles the on key up event */\n    onKeyUp(e: KeyboardEvent): void;\n\n    /** Handles the mouse down event */\n    mouseDown(e: MouseEvent): void;\n    /** Handles the mouse up event */\n    mouseUp(e: MouseEvent): void;\n    /** Handles the mouse move event */\n    mouseMove(e: MouseEvent): void;\n\n    /** Handles the touch start event */\n    touchStart(e: TouchEvent): void;\n    /** Handles the touch end event */\n    touchEnd(e: TouchEvent): void;\n    /** Handles the touch move event */\n    touchMove(e: TouchEvent): void;\n\n    /** Handles the while mouse down event */\n    whileMouseDown(e: MouseEvent): void;\n    /** Handles the while touch down event */\n    whileTouchDown(e: TouchEvent): void;\n  }\n\n  /** Handles game controls. */\n  class Controller {\n    /** Dictionary of currently pressed keys */\n    private keysDown: { [key: string]: boolean };\n    /** Unajusted mouse X coordinate */\n    private mouseClientX: number | null;\n    /** Unajusted mouse Y coordinate */\n    private mouseClientY: number | null;\n    /** Unajusted touch X coordinate */\n    private touchClientX: number | null;\n    /** Unajusted touch Y coordinate */\n    private touchClientY: number | null;\n    /** Mouse X coordinate */\n    private mouseX: number | null;\n    /** Mouse Y coordinate */\n    private mouseY: number | null;\n    /** Touch X coordinate */\n    private touchX: number | null;\n    /** Touch Y coordinate */\n    private touchY: number | null;\n    /** Event object */\n    private eventObj: Events;\n\n    /**\n     * Constructor for the Controller class.\n     * @param render - The render object\n     * @param events - The events object\n     */\n    constructor(render: Render, engine: Engine, events: Events) {\n      this.keysDown = {};\n      this.mouseClientX = null;\n      this.mouseClientY = null;\n      this.touchClientX = null;\n      this.touchClientY = null;\n      this.mouseX = null;\n      this.mouseY = null;\n      this.touchX = null;\n      this.touchY = null;\n      this.eventObj = events;\n\n      document.onkeydown = (e: KeyboardEvent) => {\n        e.preventDefault();\n        this.keysDown[e.key] = true;\n\n        switch (e.key) {\n          case `F2`:\n            engine.setLoggingPerformanceInfo(\n              !engine.isLoggingPerformanceInfo()\n            );\n            break;\n        }\n\n        this.eventObj.onKeyDown(e);\n      };\n\n      document.onkeyup = (e: KeyboardEvent) => {\n        e.preventDefault();\n        this.keysDown[e.key] = false;\n        this.eventObj.onKeyUp(e);\n      };\n\n      render.getCanvas().addEventListener(`mousedown`, (e) => {\n        e.preventDefault();\n        const camera = getCamera();\n\n        const x =\n          (e.clientX - Neutron.getRender().getCanvas().offsetLeft) *\n            (Neutron.getRender().getWidth() /\n              Neutron.getRender().getCanvas().getBoundingClientRect().width) +\n          camera.getX();\n\n        const y =\n          (e.clientY - Neutron.getRender().getCanvas().offsetTop) *\n            (Neutron.getRender().getHeight() /\n              Neutron.getRender().getCanvas().getBoundingClientRect().height) +\n          camera.getY();\n\n        this.mouseClientX = e.clientX;\n        this.mouseClientY = e.clientY;\n\n        this.mouseX = x;\n        this.mouseY = y;\n\n        this.eventObj.isMouseDown = true;\n        this.eventObj.mouseEvent = e;\n        this.eventObj.mouseDown(e);\n      });\n\n      render.getCanvas().addEventListener(`mouseup`, (e) => {\n        e.preventDefault();\n        const camera = getCamera();\n\n        const x =\n          (e.clientX - Neutron.getRender().getCanvas().offsetLeft) *\n            (Neutron.getRender().getWidth() /\n              Neutron.getRender().getCanvas().getBoundingClientRect().width) +\n          camera.getX();\n\n        const y =\n          (e.clientY - Neutron.getRender().getCanvas().offsetTop) *\n            (Neutron.getRender().getHeight() /\n              Neutron.getRender().getCanvas().getBoundingClientRect().height) +\n          camera.getY();\n\n        this.mouseClientX = e.clientX;\n        this.mouseClientY = e.clientY;\n\n        this.mouseX = x;\n        this.mouseY = y;\n\n        this.eventObj.isMouseDown = false;\n        this.eventObj.mouseEvent = e;\n        this.eventObj.mouseUp(e);\n      });\n\n      render.getCanvas().addEventListener(`mousemove`, (e) => {\n        e.preventDefault();\n        const camera = getCamera();\n\n        const x =\n          (e.clientX - Neutron.getRender().getCanvas().offsetLeft) *\n            (Neutron.getRender().getWidth() /\n              Neutron.getRender().getCanvas().getBoundingClientRect().width) +\n          camera.getX();\n\n        const y =\n          (e.clientY - Neutron.getRender().getCanvas().offsetTop) *\n            (Neutron.getRender().getHeight() /\n              Neutron.getRender().getCanvas().getBoundingClientRect().height) +\n          camera.getY();\n\n        this.mouseClientX = e.clientX;\n        this.mouseClientY = e.clientY;\n\n        this.mouseX = x;\n        this.mouseY = y;\n\n        this.eventObj.mouseMove(e);\n        this.eventObj.mouseEvent = e;\n      });\n\n      render.getCanvas().addEventListener(\"touchstart\", (e) => {\n        e.preventDefault();\n        const touch = e.touches[0];\n        const camera = getCamera();\n\n        const x =\n          (touch.clientX - Neutron.getRender().getCanvas().offsetLeft) *\n            (Neutron.getRender().getWidth() /\n              Neutron.getRender().getCanvas().getBoundingClientRect().width) +\n          camera.getX();\n\n        const y =\n          (touch.clientY - Neutron.getRender().getCanvas().offsetTop) *\n            (Neutron.getRender().getHeight() /\n              Neutron.getRender().getCanvas().getBoundingClientRect().height) +\n          camera.getY();\n\n        this.touchClientX = touch.clientX;\n        this.touchClientY = touch.clientY;\n\n        this.touchX = x;\n        this.touchY = y;\n\n        this.eventObj.touchStart(e);\n        this.eventObj.touchEvent = e;\n      });\n\n      render.getCanvas().addEventListener(\"touchend\", (e) => {\n        e.preventDefault();\n        const touch = e.touches[0];\n        const camera = getCamera();\n\n        const x =\n          (touch.clientX - getRender().getCanvas().offsetLeft) *\n            (getRender().getWidth() /\n              getRender().getCanvas().getBoundingClientRect().width) +\n          camera.getX();\n        const y =\n          (touch.clientY - getRender().getCanvas().offsetTop) *\n            (getRender().getHeight() /\n              getRender().getCanvas().getBoundingClientRect().height) +\n          camera.getY();\n\n        this.touchClientX = touch.clientX;\n        this.touchClientY = touch.clientY;\n\n        this.touchX = x;\n        this.touchY = y;\n\n        this.eventObj.touchEnd(e);\n        this.eventObj.touchEvent = e;\n      });\n\n      render.getCanvas().addEventListener(\"touchmove\", (e) => {\n        e.preventDefault();\n        const touch = e.touches[0];\n        const camera = getCamera();\n\n        const x =\n          (touch.clientX - getRender().getCanvas().offsetLeft) *\n            (getRender().getWidth() /\n              getRender().getCanvas().getBoundingClientRect().width) +\n          camera.getX();\n        const y =\n          (touch.clientY - getRender().getCanvas().offsetTop) *\n            (getRender().getHeight() /\n              getRender().getCanvas().getBoundingClientRect().height) +\n          camera.getY();\n\n        this.touchClientX = touch.clientX;\n        this.touchClientY = touch.clientY;\n\n        this.touchX = x;\n        this.touchY = y;\n\n        this.eventObj.touchMove(e);\n        this.eventObj.touchEvent = e;\n      });\n\n      document.addEventListener(`visibilitychange`, () => {\n        if (document.visibilityState !== `visible`) {\n          for (let key in this.keysDown) {\n            this.keysDown[key] = false;\n          }\n          this.eventObj.isMouseDown = false;\n          this.eventObj.isTouchDown = false;\n        }\n      });\n    }\n\n    /**\n     * Gets the key state.\n     * @param key - The key to get the state of\n     * @returns The key state\n     */\n    getKey(key: string) {\n      return this.keysDown[key] === undefined ? false : this.keysDown[key];\n    }\n\n    /**\n     * Gets the mouse X coordinate.\n     * @returns The mouse X coordinate\n     */\n    getMouseX() {\n      if (!this.mouseClientX) {\n        return null;\n      }\n\n      this.mouseX =\n        ((this.mouseClientX || 0) - getRender().getCanvas().offsetLeft) *\n          (getRender().getWidth() /\n            getRender().getCanvas().getBoundingClientRect().width) +\n        getCamera().getX();\n\n      return this.mouseX;\n    }\n\n    /**\n     * Gets the mouse Y coordinate.\n     * @returns The mouse Y coordinate\n     */\n    getMouseY() {\n      if (!this.mouseClientY) {\n        return null;\n      }\n\n      this.mouseY =\n        ((this.mouseClientY || 0) - getRender().getCanvas().offsetTop) *\n          (getRender().getHeight() /\n            getRender().getCanvas().getBoundingClientRect().height) +\n        getCamera().getY();\n\n      return this.mouseY;\n    }\n\n    /**\n     * Gets the touch X coordinate.\n     * @returns The touch X coordinate\n     */\n    getTouchX() {\n      if (!this.touchClientX) {\n        return null;\n      }\n\n      this.touchX =\n        ((this.touchClientX || 0) - getRender().getCanvas().offsetLeft) *\n          (getRender().getWidth() /\n            getRender().getCanvas().getBoundingClientRect().width) +\n        getCamera().getX();\n\n      return this.touchX;\n    }\n\n    /**\n     * Gets the touch Y coordinate.\n     * @returns The touch Y coordinate\n     */\n    getTouchY() {\n      if (!this.touchClientY) {\n        return null;\n      }\n\n      this.touchY =\n        ((this.touchClientY || 0) - getRender().getCanvas().offsetTop) *\n          (getRender().getHeight() /\n            getRender().getCanvas().getBoundingClientRect().height) +\n        getCamera().getY();\n\n      return this.touchY;\n    }\n\n    /**\n     * Gets the mouse down state.\n     * @returns The mouse down state\n     */\n    getIsMouseDown() {\n      return this.eventObj.isMouseDown;\n    }\n\n    /**\n     * Gets the touch down state.\n     * @returns The touch down state\n     */\n    getIsTouchDown() {\n      return this.eventObj.isTouchDown;\n    }\n  }\n\n  /** Handles the game state. */\n  class Game {\n    /** Array of all sprites in the game */\n    private sprites: Sprite[];\n    /** Array of all particles in the game */\n    private particles: Particle[];\n    /** The background image of the game */\n    private background: HTMLImageElement | null;\n    /** The map reader image of the game */\n    private mapReaderImage: HTMLImageElement;\n    /** The map reader canvas of the game */\n    private mapReaderCanvas: HTMLCanvasElement;\n\n    /**\n     * Creates a new game instance.\n     * Initializes an empty array of sprites, particles, background, and map reader image and canvas.\n     */\n    constructor() {\n      this.sprites = [];\n      this.particles = [];\n      this.background = null;\n      this.mapReaderImage = document.createElement(`img`);\n      this.mapReaderCanvas = document.createElement(`canvas`);\n    }\n\n    /**\n     * Sorts the sprites by stage level.\n     * @param arr - The array of sprites to sort\n     * @returns The sorted array of sprites\n     */\n    private sortSprites(arr: Sprite[]) {\n      arr.sort((a, b) => a.getStageLevel() - b.getStageLevel());\n      return arr;\n    }\n\n    /**\n     * Creates a map from an image.\n     * @param func - The function to call for each pixel\n     */\n    private createMapFromImage(\n      func: (data: Uint8ClampedArray, x: number, y: number) => void\n    ) {\n      for (let h = 0; h < this.mapReaderCanvas.height; h++) {\n        for (let w = 0; w < this.mapReaderCanvas.width; w++) {\n          const ctx = this.mapReaderCanvas.getContext(`2d`);\n\n          if (ctx === null) throw new Error(`Image map canvas ctx null!`);\n\n          const data = ctx.getImageData(w, h, 1, 1).data;\n\n          func(data, w, h);\n        }\n      }\n    }\n\n    /**\n     * Uses an image to create a map.\n     * @param image - The image to create the map from\n     * @param func - The function to call for each pixel\n     */\n    useImageToCreateMap(\n      image: HTMLImageElement,\n      func: (data: Uint8ClampedArray, x: number, y: number) => void\n    ) {\n      this.mapReaderImage = image;\n\n      this.mapReaderCanvas.width = this.mapReaderImage.width;\n      this.mapReaderCanvas.height = this.mapReaderImage.height;\n\n      const ctx = this.mapReaderCanvas.getContext(`2d`);\n\n      if (ctx === null) throw new Error(`Image map canvas ctx null!`);\n\n      ctx.drawImage(\n        this.mapReaderImage,\n        0,\n        0,\n        this.mapReaderImage.width,\n        this.mapReaderImage.height\n      );\n\n      this.createMapFromImage(func);\n\n      getEngine().start();\n    }\n\n    /**\n     * Gets the image data at a location.\n     * @param x - The x coordinate\n     * @param y - The y coordinate\n     * @returns The image data\n     */\n    getMapImageDataAtLocation(x: number, y: number) {\n      const ctx = this.mapReaderCanvas.getContext(`2d`);\n\n      if (ctx === null) {\n        throw new Error(`Image map context is null!`);\n      }\n\n      return ctx.getImageData(x, y, 1, 1);\n    }\n\n    /**\n     * Adds a new sprite to the game.\n     * @param sprites - The sprite to add\n     */\n    addNewSprite(sprites: Sprite | Sprite[]) {\n      if (Array.isArray(sprites)) {\n        sprites.forEach((sprite) => {\n          if (!this.sprites.includes(sprite)) {\n            this.sprites.push(sprite);\n          }\n        });\n      } else {\n        const sprite = sprites as Sprite;\n        if (!this.sprites.includes(sprite)) {\n          this.sprites.push(sprite);\n        }\n      }\n\n      this.sprites = this.sortSprites(this.sprites);\n    }\n\n    /**\n     * Adds a new particle to the game.\n     * @param particle - The particle to add\n     */\n    addParticle(particle: Particle | Particle[]) {\n      if (Array.isArray(particle)) {\n        particle.forEach((p) => {\n          if (!this.particles.includes(p)) {\n            this.particles.push(p);\n          }\n        });\n      } else {\n        const p = particle as Particle;\n        if (!this.particles.includes(p)) {\n          this.particles.push(p);\n        }\n      }\n    }\n\n    /**\n     * Gets a sprite by its id.\n     * @param id - The id of the sprite\n     * @returns The sprite\n     */\n    getSpriteById = (id: string) =>\n      this.sprites.filter((sprite) => sprite.getId() === id)[0];\n\n    /**\n     * Gets a particle by its id.\n     * @param id - The id of the particle\n     * @returns The particle\n     */\n    getParticleById = (id: string) =>\n      this.particles.filter((particle) => particle.getId() === id)[0];\n\n    /**\n     * Gets sprites by type.\n     * @param constructor - The constructor of the sprite\n     * @returns The sprites\n     */\n    getSpritesByType<T extends Sprite>(\n      constructor: new (...args: any[]) => T\n    ): T[] {\n      const sprites: Sprite[] = this.sprites;\n      return sprites.filter(\n        (sprite): sprite is T => sprite instanceof constructor\n      );\n    }\n\n    /**\n     * Gets particles by type.\n     * @param constructor - The constructor of the particle\n     * @returns The particles\n     */\n    getParticlesByType<T extends Particle>(\n      constructor: new (...args: any[]) => T\n    ): T[] {\n      const particles: Particle[] = this.particles;\n      return particles.filter(\n        (particle): particle is T => particle instanceof constructor\n      );\n    }\n\n    /**\n     * Deletes a sprite by its id.\n     * @param id - The id of the sprite\n     */\n    deleteSpriteById = (id: string) =>\n      (this.sprites = this.sprites.filter((sprite) => sprite.getId() !== id));\n\n    /**\n     * Deletes a particle by its id.\n     * @param id - The id of the particle\n     */\n    deleteParticleById = (id: string) =>\n      (this.particles = this.particles.filter(\n        (particle) => particle.getId() !== id\n      ));\n\n    /**\n     * Deletes sprites by type.\n     * @param type - The type of the sprite\n     */\n    deleteSpritesByType = (type: any) =>\n      (this.sprites = this.sprites.filter((sprite) => sprite! instanceof type));\n\n    /**\n     * Deletes particles by type.\n     * @param type - The type of the particle\n     */\n    deleteParticlesByType = (type: any) =>\n      (this.particles = this.particles.filter(\n        (particle) => particle! instanceof type\n      ));\n\n    /**\n     * Deletes all sprites.\n     */\n    deleteSprites = () => {\n      this.sprites.length = 0;\n    };\n\n    /**\n     * Deletes all particles.\n     */\n    deleteParticles = () => {\n      this.particles.length = 0;\n    };\n\n    /**\n     * Sets a dynamic background image.\n     * @param image - The image to set\n     * @param x - The x coordinate\n     * @param y - The y coordinate\n     * @param width - The width of the image\n     * @param height - The height of the image\n     */\n    setDynamicBackgroundImage(\n      image: HTMLImageElement,\n      x: number,\n      y: number,\n      width: number,\n      height: number\n    ) {\n      const background = new Sprite(\n        `background`,\n        x,\n        y,\n        width,\n        height,\n        `#ffffff`,\n        0\n      );\n\n      background.getCostumes().addCostume(`set`, image);\n      background.getCostumes().setCostumeById(`set`);\n\n      this.addNewSprite(background);\n    }\n\n    /**\n     * Sets a static background image.\n     * @param image - The image to set\n     */\n    setStaticBackgroundImage = (image: HTMLImageElement) => {\n      this.background = image;\n    };\n\n    /**\n     * Gets the background image.\n     * @returns The background image\n     */\n    getBackgroundImage() {\n      return this.background;\n    }\n\n    /**\n     * Gets the sprites.\n     * @returns The sprites\n     */\n    getSprites() {\n      return this.sprites;\n    }\n\n    /**\n     * Gets the particles.\n     * @returns The particles\n     */\n    getParticles() {\n      return this.particles;\n    }\n  }\n\n  /** Handles the camera. */\n  class Camera {\n    /** The x coordinate */\n    private x: number;\n    /** The y coordinate */\n    private y: number;\n    /** The sprite to follow */\n    private toFollow: Sprite | null;\n\n    /**\n     * Constructor for the Camera class.\n     */\n    constructor() {\n      this.x = 0;\n      this.y = 0;\n      this.toFollow = null;\n    }\n\n    /**\n     * Sets the sprite to follow.\n     * @param _val - The sprite to follow\n     */\n    setToFollow(_val: Sprite | null) {\n      this.toFollow = _val;\n    }\n\n    /**\n     * Gets the sprite to follow.\n     * @returns The sprite to follow\n     */\n    getToFollow() {\n      return this.toFollow;\n    }\n\n    /**\n     * Goes to a location.\n     * @param _valx - The x coordinate\n     * @param _valy - The y coordinate\n     */\n    goTo(_valx: number, _valy: number) {\n      this.setX(_valx);\n      this.setY(_valy);\n    }\n\n    /**\n     * Gets the x coordinate.\n     * @returns The x coordinate\n     */\n    getX() {\n      return this.x;\n    }\n\n    /**\n     * Sets the x coordinate.\n     * @param _val - The x coordinate\n     */\n    setX(_val: number) {\n      this.x = Number(_val.toFixed(1));\n    }\n\n    /**\n     * Gets the y coordinate.\n     * @returns The y coordinate\n     */\n    getY() {\n      return this.y;\n    }\n\n    /**\n     * Sets the y coordinate.\n     * @param _val - The y coordinate\n     */\n    setY(_val: number) {\n      this.y = Number(_val.toFixed(1));\n    }\n\n    /**\n     * Gets the width.\n     * @returns The width\n     */\n    getWidth() {\n      return getRender().getWidth;\n    }\n\n    /**\n     * Gets the height.\n     * @returns The height\n     */\n    getHeight() {\n      return getRender().getHeight;\n    }\n  }\n\n  /**\n   * Base class for all game objects in the engine.\n   * Provides common functionality for position, size, and basic game object behavior.\n   * All game objects (sprites, particles, etc.) inherit from this class.\n   */\n  class GameObject {\n    /** Unique identifier for the game object */\n    private id: string;\n    /** X coordinate of the game object's position */\n    private x: number;\n    /** Y coordinate of the game object's position */\n    private y: number;\n    /** Width of the game object */\n    private width: number;\n    /** Height of the game object */\n    private height: number;\n    /** Color of the game object in hexadecimal format */\n    private color: string;\n\n    /**\n     * Creates a new game object with the specified properties.\n     *\n     * @param id - Unique identifier for the game object\n     * @param x - Initial x coordinate\n     * @param y - Initial y coordinate\n     * @param width - Width of the game object\n     * @param height - Height of the game object\n     * @param color - Color in hexadecimal format (e.g., \"#FF0000\" for red)\n     * @throws Error if a game object with the same id already exists\n     */\n    constructor(\n      id: string,\n      x: number,\n      y: number,\n      width: number,\n      height: number,\n      color: string\n    ) {\n      if (getGame().getSpriteById(id)) {\n        throw new Error(`Sprite ${id} already exists!`);\n      }\n\n      this.id = id;\n      this.x = x;\n      this.y = y;\n      this.width = width;\n      this.height = height;\n      this.color = color;\n    }\n\n    /**\n     * Updates the game object's state.\n     * Called every game tick. Override this method to implement custom update logic.\n     */\n    update() {}\n\n    /**\n     * Draws the game object.\n     * Called every frame. Override this method to implement custom drawing logic.\n     */\n    draw() {}\n\n    /**\n     * Checks if the game object is currently visible on screen.\n     * Takes into account the camera position and viewport size.\n     *\n     * @returns true if any part of the game object is visible on screen\n     */\n    isOnScreen() {\n      return (\n        this.x + this.width >= getCamera().getX() &&\n        this.x <= getCamera().getX() + getRender().getWidth() &&\n        this.y + this.height >= getCamera().getY() &&\n        this.y <= getCamera().getY() + getRender().getHeight()\n      );\n    }\n\n    /**\n     * Moves the game object to the specified position.\n     *\n     * @param x - New x coordinate\n     * @param y - New y coordinate\n     */\n    goTo(x: number, y: number) {\n      this.x = x;\n      this.y = y;\n    }\n\n    /**\n     * Moves the game object to a predefined screen position.\n     *\n     * @param place - The screen position to move to\n     * @throws Error if an invalid screen place is specified\n     */\n    to(place: ScreenPlaces) {\n      switch (place) {\n        case ScreenPlaces.center:\n          this.goTo(\n            getRender().getWidth() / 2 - this.getWidth() / 2,\n            getRender().getHeight() / 2 - this.getHeight() / 2\n          );\n          break;\n        case ScreenPlaces.verticalCenter:\n          this.goTo(\n            this.getX(),\n            getRender().getHeight() / 2 - this.getHeight() / 2\n          );\n          break;\n        case ScreenPlaces.horizontalCenter:\n          this.goTo(\n            getRender().getWidth() / 2 - this.getWidth() / 2,\n            this.getY()\n          );\n          break;\n        case ScreenPlaces.randomPosition:\n          this.goTo(\n            Math.floor(Math.random() * getRender().getWidth()),\n            Math.floor(Math.random() * getRender().getHeight())\n          );\n          break;\n        default:\n          throw new Error(`Invalid screen place: ${place}`);\n      }\n    }\n\n    /**\n     * Gets the unique identifier of the game object.\n     *\n     * @returns The game object's id\n     */\n    getId() {\n      return this.id;\n    }\n\n    /**\n     * Sets a new unique identifier for the game object.\n     *\n     * @param id - The new id\n     * @throws Error if a game object with the same id already exists\n     */\n    setId(id: string) {\n      if (getGame().getSpriteById(id)) {\n        throw new Error(`Sprite ${id} already exists!`);\n      }\n      this.id = id;\n    }\n\n    /**\n     * Gets the x coordinate of the game object.\n     *\n     * @returns The x coordinate\n     */\n    getX() {\n      return this.x;\n    }\n\n    /**\n     * Sets the x coordinate of the game object.\n     *\n     * @param x - The new x coordinate\n     */\n    setX(x: number) {\n      this.x = x;\n    }\n\n    /**\n     * Gets the y coordinate of the game object.\n     *\n     * @returns The y coordinate\n     */\n    getY() {\n      return this.y;\n    }\n\n    /**\n     * Sets the y coordinate of the game object.\n     *\n     * @param y - The new y coordinate\n     */\n    setY(y: number) {\n      this.y = y;\n    }\n\n    /**\n     * Gets the width of the game object.\n     *\n     * @returns The width\n     */\n    getWidth() {\n      return this.width;\n    }\n\n    /**\n     * Sets the width of the game object.\n     *\n     * @param width - The new width\n     */\n    setWidth(width: number) {\n      this.width = width;\n    }\n\n    /**\n     * Gets the height of the game object.\n     *\n     * @returns The height\n     */\n    getHeight() {\n      return this.height;\n    }\n\n    /**\n     * Sets the height of the game object.\n     *\n     * @param height - The new height\n     */\n    setHeight(height: number) {\n      this.height = height;\n    }\n\n    /**\n     * Gets the color of the game object.\n     *\n     * @returns The color in hexadecimal format\n     */\n    getColor() {\n      return this.color;\n    }\n\n    /**\n     * Sets the color of the game object.\n     *\n     * @param color - The new color in hexadecimal format\n     */\n    setColor(color: string) {\n      this.color = color;\n    }\n  }\n\n  /**\n   * A sprite is a game object that can have costumes, effects, and collision detection.\n   * Sprites are the main interactive elements in a game.\n   */\n  export class Sprite extends GameObject {\n    /** The layer level of the sprite (determines drawing order) */\n    private stageLevel: number;\n    /** Manages the sprite's costumes (appearances) */\n    private costumes: Costumes;\n    /** Manages the sprite's visual effects */\n    private effects: Effects;\n    /** Handles collision detection for the sprite */\n    private collision: Collision;\n\n    /**\n     * Creates a new sprite with the specified properties.\n     *\n     * @param id - Unique identifier for the sprite\n     * @param x - Initial x coordinate\n     * @param y - Initial y coordinate\n     * @param width - Width of the sprite\n     * @param height - Height of the sprite\n     * @param color - Default color in hexadecimal format\n     * @param stageLevel - The layer level (0 is bottom, higher numbers are drawn on top)\n     * @throws Error if a sprite with the same id already exists\n     */\n    constructor(\n      id: string,\n      x: number,\n      y: number,\n      width: number,\n      height: number,\n      color: string,\n      stageLevel: number\n    ) {\n      super(id, x, y, width, height, color);\n      this.stageLevel = stageLevel;\n      this.effects = new Effects();\n      this.costumes = new Costumes();\n      this.collision = new Collision(this);\n    }\n\n    /**\n     * Gets the stage level of the sprite.\n     *\n     * @returns The stage level (0 is bottom, higher numbers are drawn on top)\n     */\n    getStageLevel() {\n      return this.stageLevel;\n    }\n\n    /**\n     * Sets the stage level of the sprite.\n     *\n     * @param stageLevel - The new stage level\n     */\n    setStageLevel(stageLevel: number) {\n      this.stageLevel = stageLevel;\n    }\n\n    /**\n     * Gets the effects manager for this sprite.\n     *\n     * @returns The Effects object managing this sprite's visual effects\n     */\n    getEffect() {\n      return this.effects;\n    }\n\n    /**\n     * Gets the costumes manager for this sprite.\n     *\n     * @returns The Costumes object managing this sprite's appearances\n     */\n    getCostumes() {\n      return this.costumes;\n    }\n\n    /**\n     * Gets the collision manager for this sprite.\n     *\n     * @returns The Collision object handling this sprite's collision detection\n     */\n    getCollision() {\n      return this.collision;\n    }\n  }\n\n  /**\n   * Manages visual effects for game objects.\n   * Handles properties like visibility, transparency, rotation, and shape effects.\n   */\n  class Effects {\n    /** Whether the game object is hidden (not rendered) */\n    private hidden: boolean;\n    /** Transparency level (0-100, where 0 is fully visible and 100 is fully transparent) */\n    private transparency: number;\n    /** Rotation angle in degrees (0-360) */\n    private rotation: number;\n    /** Whether the game object should be rendered as an ellipse instead of a rectangle */\n    private isEclipse: boolean;\n\n    /**\n     * Creates a new Effects manager with default values.\n     * Default values:\n     * - visible (not hidden)\n     * - fully opaque (0% transparency)\n     * - no rotation (0 degrees)\n     * - rectangular shape (not an ellipse)\n     */\n    constructor() {\n      this.hidden = false;\n      this.transparency = 0;\n      this.rotation = 0;\n      this.isEclipse = false;\n    }\n\n    /**\n     * Resets all effects to their default values.\n     * Makes the game object visible, fully opaque, unrotated, and rectangular.\n     */\n    clearEffects() {\n      this.hidden = false;\n      this.transparency = 0;\n      this.rotation = 0;\n      this.isEclipse = false;\n    }\n\n    /**\n     * Gets whether the game object is hidden.\n     *\n     * @returns true if the game object is hidden, false if visible\n     */\n    getHidden() {\n      return this.hidden;\n    }\n\n    /**\n     * Sets whether the game object is hidden.\n     *\n     * @param hidden - true to hide the game object, false to show it\n     */\n    setHidden(hidden: boolean) {\n      this.hidden = hidden;\n    }\n\n    /**\n     * Gets the transparency level of the game object.\n     *\n     * @returns The transparency level (0-100)\n     */\n    getTransparency() {\n      return this.transparency;\n    }\n\n    /**\n     * Sets the transparency level of the game object.\n     *\n     * @param transparency - The new transparency level (0-100)\n     * @throws Error if transparency is not between 0 and 100\n     */\n    setTransparency(transparency: number) {\n      if (transparency < 0 || transparency > 100) {\n        throw new Error(\n          `Transparency must be between 0 and 100, got ${transparency}`\n        );\n      }\n      this.transparency = transparency;\n    }\n\n    /**\n     * Gets the rotation angle of the game object.\n     *\n     * @returns The rotation angle in degrees (0-360)\n     */\n    getRotation() {\n      return this.rotation;\n    }\n\n    /**\n     * Sets the rotation angle of the game object.\n     *\n     * @param rotation - The new rotation angle in degrees\n     */\n    setRotation(rotation: number) {\n      this.rotation = rotation;\n    }\n\n    /**\n     * Gets whether the game object is rendered as an ellipse.\n     *\n     * @returns true if the game object is an ellipse, false if it's a rectangle\n     */\n    getIsEclipse() {\n      return this.isEclipse;\n    }\n\n    /**\n     * Sets whether the game object should be rendered as an ellipse.\n     *\n     * @param isEclipse - true to render as an ellipse, false to render as a rectangle\n     */\n    setIsEclipse(isEclipse: boolean) {\n      this.isEclipse = isEclipse;\n    }\n  }\n\n  /**\n   * Manages costumes (appearances) for sprites.\n   * Handles multiple costumes and switching between them.\n   */\n  class Costumes {\n    /** Map of costume IDs to their corresponding textures */\n    private costumes: { [id: string]: WebGLTexture | null };\n    /** ID of the currently active costume */\n    private id: string;\n\n    /**\n     * Creates a new Costumes manager with a default \"NONE\" costume.\n     * The \"NONE\" costume is a special costume that represents no texture.\n     */\n    constructor() {\n      this.costumes = {\n        NONE: null,\n      };\n      this.id = `NONE`;\n    }\n\n    /**\n     * Adds a new costume to the sprite.\n     *\n     * @param id - Unique identifier for the costume\n     * @param texture - The WebGL texture for the costume, or null for no texture\n     * @throws Error if the costume ID is \"NONE\" (reserved)\n     */\n    addCostume(id: string, texture: WebGLTexture | null) {\n      if (id.toUpperCase() === `NONE`) {\n        throw new Error(`Cannot add Costume as Id 'None'!`);\n      }\n\n      this.costumes[id] = texture;\n    }\n\n    /**\n     * Sets the active costume by its ID.\n     *\n     * @param id - The ID of the costume to activate\n     */\n    setCostumeById(id: string) {\n      if (id.toUpperCase() === `NONE`) {\n        this.id = `NONE`;\n      } else {\n        this.id = id;\n      }\n    }\n\n    /**\n     * Gets the currently active costume's texture.\n     *\n     * @returns The WebGL texture of the active costume, or null if no texture\n     */\n    getCostume() {\n      return this.costumes[this.id];\n    }\n\n    /**\n     * Gets the WebGL texture of the currently active costume.\n     *\n     * @returns The WebGL texture, or null if no texture is set\n     */\n    getTexture(): WebGLTexture | null {\n      return this.costumes[this.id];\n    }\n  }\n\n  /** Handles the collision of the sprite. */\n  class Collision {\n    /** The sprite this collision manager belongs to */\n    private me: Sprite;\n\n    /**\n     * Creates a new collision manager for a sprite.\n     *\n     * @param sprite - The sprite this collision manager belongs to\n     */\n    constructor(me: Sprite) {\n      this.me = me;\n    }\n\n    /**\n     * Gets all sprites touching the self sprite.\n     * @returns All sprites touching the self sprite\n     */\n    touchingSprite = () =>\n      getGame()\n        .getSprites()\n        .filter(\n          (sprite: Sprite) => this.touching(sprite) && sprite !== this.me\n        );\n\n    /**\n     * Checks if the self sprite is touching another sprite.\n     * @param other - The other sprite\n     * @returns Whether the self sprite is touching the other sprite\n     */\n    touching(other: Sprite) {\n      return (\n        this.me.getX() < other.getX() + other.getWidth() &&\n        this.me.getX() + this.me.getWidth() > other.getX() &&\n        this.me.getY() < other.getY() + other.getHeight() &&\n        this.me.getY() + this.me.getHeight() > other.getY()\n      );\n    }\n\n    /**\n     * Gets all sprites above the self sprite.\n     * @returns All sprites above the self sprite\n     */\n    getSpriteAboveSelf() {\n      this.me.setY(this.me.getY() - 1);\n      const touchingSprites = getGame()\n        .getSprites()\n        .filter(\n          (sprite: Sprite) =>\n            this.me.getCollision().touching(sprite) && this.me !== sprite\n        );\n      this.me.setY(this.me.getY() + 1);\n      return touchingSprites;\n    }\n\n    /**\n     * Gets all sprites below the self sprite.\n     * @returns All sprites below the self sprite\n     */\n    getSpriteBelowSelf() {\n      this.me.setY(this.me.getY() + 1);\n      const touchingSprites = getGame()\n        .getSprites()\n        .filter(\n          (sprite: Sprite) =>\n            this.me.getCollision().touching(sprite) && this.me !== sprite\n        );\n      this.me.setY(this.me.getY() - 1);\n      return touchingSprites;\n    }\n\n    /**\n     * Gets all sprites to the left of the self sprite.\n     * @returns All sprites to the left of the self sprite\n     */\n    getSpriteLeftSelf() {\n      this.me.setX(this.me.getX() - 1);\n      const touchingSprites = getGame()\n        .getSprites()\n        .filter(\n          (sprite: Sprite) =>\n            this.me.getCollision().touching(sprite) && this.me !== sprite\n        );\n      this.me.setX(this.me.getX() + 1);\n      return touchingSprites;\n    }\n\n    /**\n     * Gets all sprites to the right of the self sprite.\n     * @returns All sprites to the right of the self sprite\n     */\n    getSpriteRightSelf() {\n      this.me.setX(this.me.getX() + 1);\n      const touchingSprites = getGame()\n        .getSprites()\n        .filter(\n          (sprite: Sprite) =>\n            this.me.getCollision().touching(sprite) && this.me !== sprite\n        );\n      this.me.setX(this.me.getX() - 1);\n      return touchingSprites;\n    }\n  }\n\n  /** A particle game object that can be extended to create your own particles. */\n  export class Particle extends GameObject {\n    /** The effects of the particle */\n    private effects: Effects;\n\n    /**\n     * Constructor for the Particle class.\n     * @param id - The id of the particle\n     * @param x - The x position of the particle\n     * @param y - The y position of the particle\n     * @param width - The width of the particle\n     * @param height - The height of the particle\n     * @param color - The color of the particle in hexadecimal format\n     */\n    constructor(\n      id: string,\n      x: number,\n      y: number,\n      width: number,\n      height: number,\n      color: string\n    ) {\n      super(id, x, y, width, height, color);\n      this.effects = new Effects();\n    }\n\n    /**\n     * Gets the effects of the particle.\n     * @returns The effects of the particle\n     */\n    getEffects() {\n      return this.effects;\n    }\n  }\n\n  /** Platformer Sprite; Contains movement and collision features. */\n  export class Platformer extends Sprite {\n    /** The velocity of the sprite on the x axis. */\n    private vx: number;\n    /** The speed of the sprite on the x axis. */\n    private vxSpeed: number;\n    /** The maximum velocity of the sprite on the x axis. */\n    private maxVX: number | null;\n    /** The velocity of the sprite on the y axis. */\n    private vy: number;\n    /** The speed of the sprite on the y axis. */\n    private vySpeed: number;\n    /** The maximum velocity of the sprite on the y axis. */\n    private maxVY: number | null;\n    /** The gravity acceleration of the sprite. */\n    private gravityAcc: number;\n    /** Whether the sprite has a platformer below it. */\n    private hasPlatformerBelow: boolean;\n    /** Whether to check all platformers. */\n    private checkAllPlatformers: boolean;\n    /** The platformers to check collision with. */\n    private platformersToCheckCollision: Platformer[];\n\n    /**\n     * Constructor for the Platformer class.\n     * @param id - The id of the sprite\n     * @param x - The x position of the sprite\n     * @param y - The y position of the sprite\n     * @param width - The width of the sprite\n     * @param height - The height of the sprite\n     * @param color - The color of the sprite\n     * @param stageLevel - The stage level of the sprite\n     */\n    constructor(\n      id: string,\n      x: number,\n      y: number,\n      width: number,\n      height: number,\n      color: string,\n      stageLevel: number\n    ) {\n      super(id, x, y, width, height, color, stageLevel);\n      this.vx = 0;\n      this.vy = 0;\n      this.vxSpeed = 0.5;\n      this.vySpeed = 0.5;\n      this.maxVX = null;\n      this.maxVY = null;\n      this.gravityAcc = 0.2;\n      this.hasPlatformerBelow = false;\n      this.checkAllPlatformers = true;\n      this.platformersToCheckCollision = getGame().getSpritesByType(Platformer);\n    }\n\n    /**\n     * Applies gravity to the platformer sprite.\n     */\n    doGravity() {\n      if (this.checkAllPlatformers) {\n        this.platformersToCheckCollision =\n          getGame().getSpritesByType(Platformer);\n      }\n\n      this.hasPlatformerBelow = false;\n      this.setY(this.getY() + this.getVY());\n\n      this.platformersToCheckCollision.forEach((platformer) => {\n        if (this.getCollision().touching(platformer) && this !== platformer) {\n          if (this.vy < 0) {\n            this.setY(platformer.getY() + platformer.getHeight());\n          } else {\n            this.setY(platformer.getY() - this.getHeight());\n            this.hasPlatformerBelow = true;\n          }\n\n          if (this.getCollision().touching(platformer)) {\n            this.setY(this.getY() + 0.1);\n          }\n\n          this.setVY(0);\n        }\n      });\n\n      if (!this.hasPlatformerBelow) {\n        this.setVY(this.getVY() + this.getGravityAcc());\n      }\n    }\n\n    /**\n     * Moves the platformer sprite on the x axis.\n     * @param x - The amount to move the sprite on the x axis\n     */\n    moveX(x: number) {\n      if (this.checkAllPlatformers) {\n        this.platformersToCheckCollision =\n          getGame().getSpritesByType(Platformer);\n      }\n\n      this.setX(this.getX() + x);\n\n      const touchingPlatformers = this.platformersToCheckCollision.filter(\n        (platformer) =>\n          this.getCollision().touching(platformer) && this !== platformer\n      );\n\n      touchingPlatformers.forEach((platformer) => {\n        if (x > 0) this.setX(platformer.getX() - this.getWidth());\n        else this.setX(platformer.getX() + platformer.getWidth());\n      });\n    }\n\n    /**\n     * Moves the platformer sprite on the y axis.\n     * @param y - The amount to move the sprite on the y axis\n     */\n    moveY(y: number) {\n      if (this.checkAllPlatformers) {\n        this.platformersToCheckCollision =\n          getGame().getSpritesByType(Platformer);\n      }\n\n      this.setY(this.getY() + y);\n\n      const touchingPlatformers = this.platformersToCheckCollision.filter(\n        (platformer) =>\n          this.getCollision().touching(platformer) && this !== platformer\n      );\n\n      touchingPlatformers.forEach((platformer) => {\n        if (y > 0) this.setY(platformer.getY() - this.getHeight());\n        else this.setY(platformer.getY() + platformer.getHeight());\n      });\n    }\n\n    /**\n     * Makes the platformer sprite jump.\n     * @param jumpHeight - The height of the jump\n     */\n    doJump(jumpHeight: number) {\n      if (this.getCollision().getSpriteBelowSelf().length > 0) {\n        this.setVY(-jumpHeight);\n      }\n    }\n\n    /**\n     * Gets all platformers above the platformer sprite.\n     * @returns All platformers above the platformer sprite\n     */\n    getPlatformerAboveSelf() {\n      return this.getCollision()\n        .getSpriteAboveSelf()\n        .filter((sprite) => sprite instanceof Platformer);\n    }\n\n    /**\n     * Gets all platformers below the platformer sprite.\n     * @returns All platformers below the platformer sprite\n     */\n    getPlatformerBelowSelf() {\n      return this.getCollision()\n        .getSpriteBelowSelf()\n        .filter((sprite) => sprite instanceof Platformer);\n    }\n\n    /**\n     * Gets all platformers to the left of the platformer sprite.\n     * @returns All platformers to the left of the platformer sprite\n     */\n    getPlatformerLeftSelf() {\n      return this.getCollision()\n        .getSpriteLeftSelf()\n        .filter((sprite) => sprite instanceof Platformer);\n    }\n\n    /**\n     * Gets all platformers to the right of the platformer sprite.\n     * @returns All platformers to the right of the platformer sprite\n     */\n    getPlatformerRightSelf() {\n      return this.getCollision()\n        .getSpriteRightSelf()\n        .filter((sprite) => sprite instanceof Platformer);\n    }\n\n    /**\n     * Adds friction to the platformer sprite on the x axis.\n     * @param friction - The friction to add\n     */\n    addFrictionX(friction: number) {\n      this.setVX(this.getVX() * friction);\n      if (Math.abs(this.getVX()) < 0.3) this.setVX(0);\n    }\n\n    /**\n     * Adds friction to the platformer sprite on the y axis.\n     * @param friction - The friction to add\n     */\n    addFrictionY(friction: number) {\n      this.setVY(this.getVY() * friction);\n      if (Math.abs(this.getVY()) < 0.3) this.setVY(0);\n    }\n\n    /**\n     * Gets the velocity of the platformer sprite on the x axis.\n     * @returns The velocity of the platformer sprite on the x axis\n     */\n    getVX() {\n      return this.vx;\n    }\n\n    /**\n     * Sets the velocity of the platformer sprite on the x axis.\n     * @param _val - The velocity to set\n     */\n    setVX(_val: number) {\n      this.vx = _val;\n      this.vx = Number(this.vx.toFixed(1));\n      if (this.maxVX !== null && this.vx > this.maxVX) this.vx = this.maxVX;\n      else if (this.maxVX !== null && this.vx < -this.maxVX)\n        this.vx = -this.maxVX;\n    }\n\n    /**\n     * Gets the speed of the platformer sprite on the x axis.\n     * @returns The speed of the platformer sprite on the x axis\n     */\n    getVXSpeed() {\n      return this.vxSpeed;\n    }\n\n    /**\n     * Sets the speed of the platformer sprite on the x axis.\n     * @param _val - The speed to set\n     */\n    setVXSpeed(_val: number) {\n      this.vxSpeed = _val;\n      this.vxSpeed = Number(this.vxSpeed.toFixed(1));\n    }\n\n    /**\n     * Gets the maximum velocity of the platformer sprite on the x axis.\n     * @returns The maximum velocity of the platformer sprite on the x axis\n     */\n    getMaxVX() {\n      return this.maxVX;\n    }\n\n    /**\n     * Sets the maximum velocity of the platformer sprite on the x axis.\n     * @param _val - The maximum velocity to set\n     */\n    setMaxVX(_val: number | null) {\n      this.maxVX = _val;\n    }\n\n    /**\n     * Gets the velocity of the platformer sprite on the y axis.\n     * @returns The velocity of the platformer sprite on the y axis\n     */\n    getVY() {\n      return this.vy;\n    }\n\n    /**\n     * Sets the velocity of the platformer sprite on the y axis.\n     * @param _val - The velocity to set\n     */\n    setVY(_val: number) {\n      this.vy = _val;\n      this.vy = Number(this.vy.toFixed(1));\n      if (this.maxVY !== null && this.vy > this.maxVY) this.vy = this.maxVY;\n      else if (this.maxVY !== null && this.vy < -this.maxVY)\n        this.vy = -this.maxVY;\n    }\n\n    /**\n     * Gets the speed of the platformer sprite on the y axis.\n     * @returns The speed of the platformer sprite on the y axis\n     */\n    getVYSpeed() {\n      return this.vySpeed;\n    }\n\n    /**\n     * Sets the speed of the platformer sprite on the y axis.\n     * @param _val - The speed to set\n     */\n    setVYSpeed(_val: number) {\n      this.vySpeed = _val;\n      this.vySpeed = Number(this.vySpeed.toFixed(1));\n    }\n\n    /**\n     * Gets the maximum velocity of the platformer sprite on the y axis.\n     * @returns The maximum velocity of the platformer sprite on the y axis\n     */\n    getMaxVY() {\n      return this.maxVY;\n    }\n\n    /**\n     * Sets the maximum velocity of the platformer sprite on the y axis.\n     * @param _val - The maximum velocity to set\n     */\n    setMaxVY(_val: number | null) {\n      this.maxVY = _val;\n    }\n\n    /**\n     * Gets the gravity acceleration of the platformer sprite.\n     * @returns The gravity acceleration of the platformer sprite\n     */\n    getGravityAcc() {\n      return this.gravityAcc;\n    }\n\n    /**\n     * Sets the gravity acceleration of the platformer sprite.\n     * @param _val - The gravity acceleration to set\n     */\n    setGravityAcc(_val: number) {\n      this.gravityAcc = _val;\n    }\n\n    /**\n     * Gets the platformers to check collision with.\n     * @returns The platformers to check collision with\n     */\n    getPlatformersToCheckCollision() {\n      return this.platformersToCheckCollision;\n    }\n\n    /**\n     * Sets the platformers to check collision with.\n     * @param _val - The platformers to check collision with\n     */\n    setPlatformerSpritesToCheckCollisionWith(_val: Platformer[]) {\n      this.platformersToCheckCollision = _val;\n    }\n  }\n\n  /** The places on the screen. */\n  export enum ScreenPlaces {\n    center,\n    verticalCenter,\n    horizontalCenter,\n    randomPosition,\n  }\n\n  const engine = new Engine();\n\n  /**\n   * Gets the engine instance.\n   * @returns The engine instance\n   */\n  export const getEngine = (): Engine => engine;\n\n  /**\n   * Gets the render instance.\n   * @returns The render instance\n   */\n  export let getRender: () => Render;\n\n  /**\n   * Gets the loader instance.\n   * @returns The loader instance\n   */\n  export let getLoader: () => Loader;\n\n  /**\n   * Gets the events instance.\n   * @returns The events instance\n   */\n  export let getEvents: () => Events;\n\n  /**\n   * Gets the controller instance.\n   * @returns The controller instance\n   */\n  export let getController: () => Controller;\n\n  /**\n   * Gets the game instance.\n   * @returns The game instance\n   */\n  export let getGame: () => Game;\n\n  /**\n   * Gets the camera instance.\n   * @returns The camera instance\n   */\n  export let getCamera: () => Camera;\n\n  /**\n   * Initializes the engine.\n   * @param engineSettings - The engine settings\n   */\n  export let init: (engineSettings: EngineSettings) => void = (\n    engineSettings: EngineSettings\n  ) => {\n    engine.init(engineSettings);\n  };\n}\n"],"mappings":"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","names":["Neutron","camera","engine","ScreenPlaces"]}